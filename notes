size > 3 ------ row and column
test : if the 0 surendded by walls


11111111
10000001
1CCC00C1
100P0001
10000011
100E00E1
11111111

if player == 2
if exit == 2 /// mmm if closed the second exit
if collect == 0


111
1P1
1E1
// need to handle this case

11111111111111111111111111
10000000000000001000000001
1CCC00C10000E0001000000001
100P0001000000001000000001
11111111111111111111111111

pc icron :    1920x1080
perfect size : 1920, 1000

# player images
i < 1500  ---> put the image 1
j++; put the background image
i < 1500  ---> put the image 2

tilemap : where the player can walk




11111111111111111111111
1P1C00100C10001C000C1E1
101010101010101010101C1
1C100010001C10100010101
10100010001010101C10101
10100010C01000101010101
10001010101000001010101
101C0010C0100C101010101
10100010101010101010101
1C1C0010001010100010101
10101000101010001010101
10100010C010C0101010101
10101000000010001010101
1010C010001000100C10001
11111111111111111111111

#B4B4B4

mlx_destroy image to delete all the leaks


11111111111111111111111111111111
10100000100000100000000000000001
10111011101110100000P00000000001
100010001000101000000000000000E1
11001000001110100000000000000001
100010100010001000000000000C0001
10111011111011100000000000000001
10101010001010000000000000000001
10100000001000000000000000000001
10111111001110000000000000000001
10000001000010000000000000000001
11111001000100000000000000000001
10100000000010000000000000000001
10100000000010000000000000000001
10101000000010000000000000000001
10001000000000000000000000000001
11111111111111111111111111111111

 error :
 if a put x in the map it works

 1111111111111111
1C0C0C0P0C0C0C01
10C0C0C0C0C0C0C1
1C0C0C0C0C0C0C01
10C0C0C0C0C0C0C1
1C0C0C0C0C0C0C0p
10C0C0C0C0C0C0C1
1C0C00E00C0C0C01
1111111111111111



	int moves = 1;
	int animation = 0;
	int width = 60;
	int height = 60 ;

	void *effect;
	void *enemy[5];
	int e_ani = 0;
	t_enemy e_nmb[100];
	int e_index = 0;
	int enemy_nmb;

enemy
{
	int e_x = k;
	int e_y = i;
	int moves;                // right_or_left  data->e_nmb[data->e_index].moves = 1; or 0
	int pre_x = e_x;
	int pre_y = e_y;
} t_enemy;




	(*data)->e_nmb->moves = 0;


11111111111111111111111
1000A1000A0000000E00001
1000010000A00000P000001
1A000000000A00000000A01
100A00000000A0000A00001
10000A0A000000000000001
10001010101000001010101
101C0010C0100C101010101
10100010101010101010101
1C1C0010A0101010A010101
101010A0101010001010101
10100010C010C0101010101
10101000000010A01010101
101AC01000100A100C10A01
11111111111111111111111

11111111111111111111111111111111
100000000A000000000100000P0000E1
10000000000A000C0000000000000001
10000000000000000000000A00000001
1000000000000A000000000000000001
100000000000000000A0000000000001
10000000000000000000000000000001
10000000000000000000000000000001
10000000000000000000000000000001
10000000000000000000000000000001
10000000000000000000000000000001
10000000000000000000000000000001
10000000000000000000000000000001
10000000000000000000000000000001
10000000000000000000000000000001
10000000000000000000000000000001
11111111111111111111111111111111

		//usleep(70000); // enemy <= 3
		//usleep(40000);
		//usleep(100000);
		//usleep(20000); // enemy <= 6 7 8 9
		//usleep(14000);  // 11 12 13 14
		//usleep(9000); // 16 17 18 19

what is

(*data)->e_index = 0;         enemy number 0 in the struct and so on
	(*data)->e_ani = 0;
	(*data)->enemy_nmb = 0;   i used this to store how many enemies i have, bc the e_index is changing in each loop
data->e_nmb[data->e_index].moves     which direction to move to left or right


----
- no player in the map, flood fill give some invalid read size
- the moves must appear on screan 'moves : 0'
